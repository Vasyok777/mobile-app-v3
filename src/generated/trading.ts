// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "trading.proto" (package "trading", syntax proto3)
// tslint:disable
import type {
	BinaryReadOptions,
	BinaryWriteOptions,
	IBinaryReader,
	IBinaryWriter,
	PartialMessage,
} from '@protobuf-ts/runtime'
import {
	MessageType,
	reflectionMergePartial,
	UnknownFieldHandler,
	WireType,
} from '@protobuf-ts/runtime'
import { ServiceType } from '@protobuf-ts/runtime-rpc'
/**
 * @generated from protobuf message trading.StartSessionRequest
 */
export interface StartSessionRequest {
	/**
	 * @generated from protobuf field: int64 user_id = 1;
	 */
	userId: bigint
}
/**
 * @generated from protobuf message trading.StartSessionResponse
 */
export interface StartSessionResponse {
	/**
	 * @generated from protobuf field: string session_id = 1;
	 */
	sessionId: string
	/**
	 * @generated from protobuf field: double initial_price = 2;
	 */
	initialPrice: number
}
/**
 * @generated from protobuf message trading.GetCurrentPriceRequest
 */
export interface GetCurrentPriceRequest {
	/**
	 * @generated from protobuf field: string session_id = 1;
	 */
	sessionId: string
}
/**
 * @generated from protobuf message trading.GetCurrentPriceResponse
 */
export interface GetCurrentPriceResponse {
	/**
	 * @generated from protobuf field: double price = 1;
	 */
	price: number
	/**
	 * @generated from protobuf field: int64 timestamp = 2;
	 */
	timestamp: bigint
}
/**
 * @generated from protobuf message trading.PlaceBetRequest
 */
export interface PlaceBetRequest {
	/**
	 * @generated from protobuf field: string session_id = 1;
	 */
	sessionId: string
	/**
	 * @generated from protobuf field: int64 user_id = 2;
	 */
	userId: bigint
	/**
	 * @generated from protobuf field: trading.BetDirection direction = 3;
	 */
	direction: BetDirection
}
/**
 * @generated from protobuf message trading.PlaceBetResponse
 */
export interface PlaceBetResponse {
	/**
	 * @generated from protobuf field: string bet_id = 1;
	 */
	betId: string
	/**
	 * @generated from protobuf field: double entry_price = 2;
	 */
	entryPrice: number
}
/**
 * @generated from protobuf message trading.GetBetResultRequest
 */
export interface GetBetResultRequest {
	/**
	 * @generated from protobuf field: string bet_id = 1;
	 */
	betId: string
}
/**
 * @generated from protobuf message trading.GetBetResultResponse
 */
export interface GetBetResultResponse {
	/**
	 * @generated from protobuf field: bool win = 1;
	 */
	win: boolean
	/**
	 * @generated from protobuf field: int32 points = 2;
	 */
	points: number
	/**
	 * @generated from protobuf field: double entry_price = 3;
	 */
	entryPrice: number
	/**
	 * @generated from protobuf field: double closing_price = 4;
	 */
	closingPrice: number
}
/**
 * @generated from protobuf message trading.GetPriceHistoryRequest
 */
export interface GetPriceHistoryRequest {
	/**
	 * @generated from protobuf field: int64 start_time = 1;
	 */
	startTime: bigint
	/**
	 * @generated from protobuf field: int64 end_time = 2;
	 */
	endTime: bigint
}
/**
 * @generated from protobuf message trading.GetPriceHistoryResponse
 */
export interface GetPriceHistoryResponse {
	/**
	 * @generated from protobuf field: repeated trading.PricePoint price_points = 1;
	 */
	pricePoints: PricePoint[]
}
/**
 * @generated from protobuf message trading.PricePoint
 */
export interface PricePoint {
	/**
	 * @generated from protobuf field: double price = 1;
	 */
	price: number
	/**
	 * @generated from protobuf field: int64 timestamp = 2;
	 */
	timestamp: bigint
}
/**
 * @generated from protobuf message trading.StreamPriceRequest
 */
export interface StreamPriceRequest {
	/**
	 * @generated from protobuf field: string session_id = 1;
	 */
	sessionId: string
}
/**
 * @generated from protobuf message trading.PriceUpdate
 */
export interface PriceUpdate {
	/**
	 * @generated from protobuf field: double price = 1;
	 */
	price: number
	/**
	 * @generated from protobuf field: int64 timestamp = 2;
	 */
	timestamp: bigint
}
/**
 * @generated from protobuf enum trading.BetDirection
 */
export enum BetDirection {
	/**
	 * @generated from protobuf enum value: UP = 0;
	 */
	UP = 0,
	/**
	 * @generated from protobuf enum value: DOWN = 1;
	 */
	DOWN = 1,
}
// @generated message type with reflection information, may provide speed optimized methods
class StartSessionRequest$Type extends MessageType<StartSessionRequest> {
	constructor() {
		super('trading.StartSessionRequest', [
			{
				no: 1,
				name: 'user_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<StartSessionRequest>): StartSessionRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.userId = BigInt(0)
		if (value !== undefined)
			reflectionMergePartial<StartSessionRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: StartSessionRequest
	): StartSessionRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 user_id */ 1:
					message.userId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: StartSessionRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 user_id = 1; */
		if (message.userId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.userId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.StartSessionRequest
 */
export const StartSessionRequest = new StartSessionRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class StartSessionResponse$Type extends MessageType<StartSessionResponse> {
	constructor() {
		super('trading.StartSessionResponse', [
			{ no: 1, name: 'session_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 2,
				name: 'initial_price',
				kind: 'scalar',
				T: 1 /*ScalarType.DOUBLE*/,
			},
		])
	}
	create(value?: PartialMessage<StartSessionResponse>): StartSessionResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.sessionId = ''
		message.initialPrice = 0
		if (value !== undefined)
			reflectionMergePartial<StartSessionResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: StartSessionResponse
	): StartSessionResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string session_id */ 1:
					message.sessionId = reader.string()
					break
				case /* double initial_price */ 2:
					message.initialPrice = reader.double()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: StartSessionResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string session_id = 1; */
		if (message.sessionId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.sessionId)
		/* double initial_price = 2; */
		if (message.initialPrice !== 0)
			writer.tag(2, WireType.Bit64).double(message.initialPrice)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.StartSessionResponse
 */
export const StartSessionResponse = new StartSessionResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetCurrentPriceRequest$Type extends MessageType<GetCurrentPriceRequest> {
	constructor() {
		super('trading.GetCurrentPriceRequest', [
			{ no: 1, name: 'session_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(
		value?: PartialMessage<GetCurrentPriceRequest>
	): GetCurrentPriceRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.sessionId = ''
		if (value !== undefined)
			reflectionMergePartial<GetCurrentPriceRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetCurrentPriceRequest
	): GetCurrentPriceRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string session_id */ 1:
					message.sessionId = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetCurrentPriceRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string session_id = 1; */
		if (message.sessionId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.sessionId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.GetCurrentPriceRequest
 */
export const GetCurrentPriceRequest = new GetCurrentPriceRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetCurrentPriceResponse$Type extends MessageType<GetCurrentPriceResponse> {
	constructor() {
		super('trading.GetCurrentPriceResponse', [
			{ no: 1, name: 'price', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/ },
			{
				no: 2,
				name: 'timestamp',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(
		value?: PartialMessage<GetCurrentPriceResponse>
	): GetCurrentPriceResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.price = 0
		message.timestamp = 0n
		if (value !== undefined)
			reflectionMergePartial<GetCurrentPriceResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetCurrentPriceResponse
	): GetCurrentPriceResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* double price */ 1:
					message.price = reader.double()
					break
				case /* int64 timestamp */ 2:
					message.timestamp = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetCurrentPriceResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* double price = 1; */
		if (message.price !== 0) writer.tag(1, WireType.Bit64).double(message.price)
		/* int64 timestamp = 2; */
		if (message.timestamp !== 0n)
			writer.tag(2, WireType.Varint).int64(message.timestamp)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.GetCurrentPriceResponse
 */
export const GetCurrentPriceResponse = new GetCurrentPriceResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PlaceBetRequest$Type extends MessageType<PlaceBetRequest> {
	constructor() {
		super('trading.PlaceBetRequest', [
			{ no: 1, name: 'session_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 2,
				name: 'user_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 3,
				name: 'direction',
				kind: 'enum',
				T: () => ['trading.BetDirection', BetDirection],
			},
		])
	}
	create(value?: PartialMessage<PlaceBetRequest>): PlaceBetRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.sessionId = ''
		message.userId = 0n
		message.direction = 0
		if (value !== undefined)
			reflectionMergePartial<PlaceBetRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: PlaceBetRequest
	): PlaceBetRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string session_id */ 1:
					message.sessionId = reader.string()
					break
				case /* int64 user_id */ 2:
					message.userId = reader.int64().toBigInt()
					break
				case /* trading.BetDirection direction */ 3:
					message.direction = reader.int32()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: PlaceBetRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string session_id = 1; */
		if (message.sessionId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.sessionId)
		/* int64 user_id = 2; */
		if (message.userId !== 0n)
			writer.tag(2, WireType.Varint).int64(message.userId)
		/* trading.BetDirection direction = 3; */
		if (message.direction !== 0)
			writer.tag(3, WireType.Varint).int32(message.direction)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.PlaceBetRequest
 */
export const PlaceBetRequest = new PlaceBetRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PlaceBetResponse$Type extends MessageType<PlaceBetResponse> {
	constructor() {
		super('trading.PlaceBetResponse', [
			{ no: 1, name: 'bet_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 2,
				name: 'entry_price',
				kind: 'scalar',
				T: 1 /*ScalarType.DOUBLE*/,
			},
		])
	}
	create(value?: PartialMessage<PlaceBetResponse>): PlaceBetResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.betId = ''
		message.entryPrice = 0
		if (value !== undefined)
			reflectionMergePartial<PlaceBetResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: PlaceBetResponse
	): PlaceBetResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string bet_id */ 1:
					message.betId = reader.string()
					break
				case /* double entry_price */ 2:
					message.entryPrice = reader.double()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: PlaceBetResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string bet_id = 1; */
		if (message.betId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.betId)
		/* double entry_price = 2; */
		if (message.entryPrice !== 0)
			writer.tag(2, WireType.Bit64).double(message.entryPrice)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.PlaceBetResponse
 */
export const PlaceBetResponse = new PlaceBetResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetBetResultRequest$Type extends MessageType<GetBetResultRequest> {
	constructor() {
		super('trading.GetBetResultRequest', [
			{ no: 1, name: 'bet_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(value?: PartialMessage<GetBetResultRequest>): GetBetResultRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.betId = ''
		if (value !== undefined)
			reflectionMergePartial<GetBetResultRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetBetResultRequest
	): GetBetResultRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string bet_id */ 1:
					message.betId = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetBetResultRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string bet_id = 1; */
		if (message.betId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.betId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.GetBetResultRequest
 */
export const GetBetResultRequest = new GetBetResultRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetBetResultResponse$Type extends MessageType<GetBetResultResponse> {
	constructor() {
		super('trading.GetBetResultResponse', [
			{ no: 1, name: 'win', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 2, name: 'points', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{
				no: 3,
				name: 'entry_price',
				kind: 'scalar',
				T: 1 /*ScalarType.DOUBLE*/,
			},
			{
				no: 4,
				name: 'closing_price',
				kind: 'scalar',
				T: 1 /*ScalarType.DOUBLE*/,
			},
		])
	}
	create(value?: PartialMessage<GetBetResultResponse>): GetBetResultResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.win = false
		message.points = 0
		message.entryPrice = 0
		message.closingPrice = 0
		if (value !== undefined)
			reflectionMergePartial<GetBetResultResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetBetResultResponse
	): GetBetResultResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool win */ 1:
					message.win = reader.bool()
					break
				case /* int32 points */ 2:
					message.points = reader.int32()
					break
				case /* double entry_price */ 3:
					message.entryPrice = reader.double()
					break
				case /* double closing_price */ 4:
					message.closingPrice = reader.double()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetBetResultResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool win = 1; */
		if (message.win !== false) writer.tag(1, WireType.Varint).bool(message.win)
		/* int32 points = 2; */
		if (message.points !== 0)
			writer.tag(2, WireType.Varint).int32(message.points)
		/* double entry_price = 3; */
		if (message.entryPrice !== 0)
			writer.tag(3, WireType.Bit64).double(message.entryPrice)
		/* double closing_price = 4; */
		if (message.closingPrice !== 0)
			writer.tag(4, WireType.Bit64).double(message.closingPrice)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.GetBetResultResponse
 */
export const GetBetResultResponse = new GetBetResultResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetPriceHistoryRequest$Type extends MessageType<GetPriceHistoryRequest> {
	constructor() {
		super('trading.GetPriceHistoryRequest', [
			{
				no: 1,
				name: 'start_time',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'end_time',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(
		value?: PartialMessage<GetPriceHistoryRequest>
	): GetPriceHistoryRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.startTime = 0n
		message.endTime = 0n
		if (value !== undefined)
			reflectionMergePartial<GetPriceHistoryRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetPriceHistoryRequest
	): GetPriceHistoryRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 start_time */ 1:
					message.startTime = reader.int64().toBigInt()
					break
				case /* int64 end_time */ 2:
					message.endTime = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetPriceHistoryRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 start_time = 1; */
		if (message.startTime !== 0n)
			writer.tag(1, WireType.Varint).int64(message.startTime)
		/* int64 end_time = 2; */
		if (message.endTime !== 0n)
			writer.tag(2, WireType.Varint).int64(message.endTime)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.GetPriceHistoryRequest
 */
export const GetPriceHistoryRequest = new GetPriceHistoryRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetPriceHistoryResponse$Type extends MessageType<GetPriceHistoryResponse> {
	constructor() {
		super('trading.GetPriceHistoryResponse', [
			{
				no: 1,
				name: 'price_points',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => PricePoint,
			},
		])
	}
	create(
		value?: PartialMessage<GetPriceHistoryResponse>
	): GetPriceHistoryResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.pricePoints = []
		if (value !== undefined)
			reflectionMergePartial<GetPriceHistoryResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetPriceHistoryResponse
	): GetPriceHistoryResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* repeated trading.PricePoint price_points */ 1:
					message.pricePoints.push(
						PricePoint.internalBinaryRead(reader, reader.uint32(), options)
					)
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetPriceHistoryResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* repeated trading.PricePoint price_points = 1; */
		for (let i = 0; i < message.pricePoints.length; i++)
			PricePoint.internalBinaryWrite(
				message.pricePoints[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options
			).join()
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.GetPriceHistoryResponse
 */
export const GetPriceHistoryResponse = new GetPriceHistoryResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PricePoint$Type extends MessageType<PricePoint> {
	constructor() {
		super('trading.PricePoint', [
			{ no: 1, name: 'price', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/ },
			{
				no: 2,
				name: 'timestamp',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<PricePoint>): PricePoint {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.price = 0
		message.timestamp = 0n
		if (value !== undefined)
			reflectionMergePartial<PricePoint>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: PricePoint
	): PricePoint {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* double price */ 1:
					message.price = reader.double()
					break
				case /* int64 timestamp */ 2:
					message.timestamp = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: PricePoint,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* double price = 1; */
		if (message.price !== 0) writer.tag(1, WireType.Bit64).double(message.price)
		/* int64 timestamp = 2; */
		if (message.timestamp !== 0n)
			writer.tag(2, WireType.Varint).int64(message.timestamp)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.PricePoint
 */
export const PricePoint = new PricePoint$Type()
// @generated message type with reflection information, may provide speed optimized methods
class StreamPriceRequest$Type extends MessageType<StreamPriceRequest> {
	constructor() {
		super('trading.StreamPriceRequest', [
			{ no: 1, name: 'session_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(value?: PartialMessage<StreamPriceRequest>): StreamPriceRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.sessionId = ''
		if (value !== undefined)
			reflectionMergePartial<StreamPriceRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: StreamPriceRequest
	): StreamPriceRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* string session_id */ 1:
					message.sessionId = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: StreamPriceRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string session_id = 1; */
		if (message.sessionId !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.sessionId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.StreamPriceRequest
 */
export const StreamPriceRequest = new StreamPriceRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PriceUpdate$Type extends MessageType<PriceUpdate> {
	constructor() {
		super('trading.PriceUpdate', [
			{ no: 1, name: 'price', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/ },
			{
				no: 2,
				name: 'timestamp',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<PriceUpdate>): PriceUpdate {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.price = 0
		message.timestamp = 0n
		if (value !== undefined)
			reflectionMergePartial<PriceUpdate>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: PriceUpdate
	): PriceUpdate {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* double price */ 1:
					message.price = reader.double()
					break
				case /* int64 timestamp */ 2:
					message.timestamp = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: PriceUpdate,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* double price = 1; */
		if (message.price !== 0) writer.tag(1, WireType.Bit64).double(message.price)
		/* int64 timestamp = 2; */
		if (message.timestamp !== 0n)
			writer.tag(2, WireType.Varint).int64(message.timestamp)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message trading.PriceUpdate
 */
export const PriceUpdate = new PriceUpdate$Type()
/**
 * @generated ServiceType for protobuf service trading.TradingGameService
 */
export const TradingGameService = new ServiceType(
	'trading.TradingGameService',
	[
		{
			name: 'StartSession',
			options: {},
			I: StartSessionRequest,
			O: StartSessionResponse,
		},
		{
			name: 'GetCurrentPrice',
			options: {},
			I: GetCurrentPriceRequest,
			O: GetCurrentPriceResponse,
		},
		{ name: 'PlaceBet', options: {}, I: PlaceBetRequest, O: PlaceBetResponse },
		{
			name: 'GetBetResult',
			options: {},
			I: GetBetResultRequest,
			O: GetBetResultResponse,
		},
		{
			name: 'GetPriceHistory',
			options: {},
			I: GetPriceHistoryRequest,
			O: GetPriceHistoryResponse,
		},
		{
			name: 'StreamPrice',
			serverStreaming: true,
			options: {},
			I: StreamPriceRequest,
			O: PriceUpdate,
		},
	]
)
