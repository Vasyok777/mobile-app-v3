// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "user.proto" (package "user", syntax proto3)
// tslint:disable
import type {
	BinaryReadOptions,
	BinaryWriteOptions,
	IBinaryReader,
	IBinaryWriter,
	PartialMessage,
} from '@protobuf-ts/runtime'
import {
	MessageType,
	reflectionMergePartial,
	UnknownFieldHandler,
	WireType,
} from '@protobuf-ts/runtime'
import { ServiceType } from '@protobuf-ts/runtime-rpc'
/**
 * @generated from protobuf message user.User
 */
export interface User {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
	/**
	 * @generated from protobuf field: int64 created_at = 2;
	 */
	createdAt: bigint
	/**
	 * @generated from protobuf field: string nickname = 3;
	 */
	nickname: string
	/**
	 * @generated from protobuf field: int64 points = 4;
	 */
	points: bigint
}
/**
 * @generated from protobuf message user.UpdateUserNicknameRequest
 */
export interface UpdateUserNicknameRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
	/**
	 * @generated from protobuf field: string new_nickname = 2;
	 */
	newNickname: string
}
/**
 * @generated from protobuf message user.Task
 */
export interface Task {
	/**
	 * @generated from protobuf field: int64 id = 1;
	 */
	id: bigint
	/**
	 * @generated from protobuf field: string name = 2;
	 */
	name: string
	/**
	 * @generated from protobuf field: string description = 3;
	 */
	description: string
	/**
	 * @generated from protobuf field: bool is_automatic = 4;
	 */
	isAutomatic: boolean
	/**
	 * @generated from protobuf field: int64 reward_points = 5;
	 */
	rewardPoints: bigint
	/**
	 * @generated from protobuf field: optional int64 progress = 6;
	 */
	progress?: bigint
	/**
	 * @generated from protobuf field: optional int64 goal = 7;
	 */
	goal?: bigint
	/**
	 * @generated from protobuf field: bool completed = 8;
	 */
	completed: boolean
}
/**
 * @generated from protobuf message user.GetUserTasksRequest
 */
export interface GetUserTasksRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
}
/**
 * @generated from protobuf message user.GetUserTasksResponse
 */
export interface GetUserTasksResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: repeated user.Task tasks = 2;
	 */
	tasks: Task[]
	/**
	 * @generated from protobuf field: optional string message = 3;
	 */
	message?: string
}
/**
 * @generated from protobuf message user.CompleteTaskRequest
 */
export interface CompleteTaskRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
	/**
	 * @generated from protobuf field: int64 task_id = 2;
	 */
	taskId: bigint
}
/**
 * @generated from protobuf message user.CompleteTaskResponse
 */
export interface CompleteTaskResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional string message = 2;
	 */
	message?: string
}
/**
 * @generated from protobuf message user.CreateUserRequest
 */
export interface CreateUserRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
	/**
	 * @generated from protobuf field: optional int64 referrer_id = 2;
	 */
	referrerId?: bigint
	/**
	 * @generated from protobuf field: string nickname = 3;
	 */
	nickname: string
}
/**
 * @generated from protobuf message user.CreateUserResponse
 */
export interface CreateUserResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional user.User user = 2;
	 */
	user?: User
	/**
	 * @generated from protobuf field: optional string message = 3;
	 */
	message?: string
	/**
	 * @generated from protobuf field: bool user_exists = 4;
	 */
	userExists: boolean // Новое поле
}
/**
 * @generated from protobuf message user.UserResponse
 */
export interface UserResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional user.User user = 2;
	 */
	user?: User
	/**
	 * @generated from protobuf field: optional string message = 3;
	 */
	message?: string
}
/**
 * @generated from protobuf message user.UserRequest
 */
export interface UserRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
}
/**
 * @generated from protobuf message user.GetUserReferralsRequest
 */
export interface GetUserReferralsRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
}
/**
 * @generated from protobuf message user.UserReferralsResponse
 */
export interface UserReferralsResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional user.UserReferrals data = 2;
	 */
	data?: UserReferrals
	/**
	 * @generated from protobuf field: optional string message = 3;
	 */
	message?: string
}
/**
 * @generated from protobuf message user.UserReferrals
 */
export interface UserReferrals {
	/**
	 * @generated from protobuf field: repeated int64 referrals = 1;
	 */
	referrals: bigint[]
	/**
	 * @generated from protobuf field: int64 total_count = 2;
	 */
	totalCount: bigint
}
/**
 * @generated from protobuf message user.UpdateUserPointsRequest
 */
export interface UpdateUserPointsRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
	/**
	 * @generated from protobuf field: int64 points = 2;
	 */
	points: bigint
}
/**
 * @generated from protobuf message user.CheckAndUpdateTasksRequest
 */
export interface CheckAndUpdateTasksRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
}
/**
 * @generated from protobuf message user.CheckAndUpdateTasksResponse
 */
export interface CheckAndUpdateTasksResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional string message = 2;
	 */
	message?: string
}
/**
 * @generated from protobuf message user.UserAvatar
 */
export interface UserAvatar {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
	/**
	 * @generated from protobuf field: string avatar_url = 2;
	 */
	avatarUrl: string
	/**
	 * @generated from protobuf field: int64 updated_at = 3;
	 */
	updatedAt: bigint
}
/**
 * @generated from protobuf message user.SetUserAvatarRequest
 */
export interface SetUserAvatarRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
	/**
	 * @generated from protobuf field: string avatar_url = 2;
	 */
	avatarUrl: string
}
/**
 * @generated from protobuf message user.SetUserAvatarResponse
 */
export interface SetUserAvatarResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional string message = 2;
	 */
	message?: string
}
/**
 * @generated from protobuf message user.GetUserAvatarRequest
 */
export interface GetUserAvatarRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
}
/**
 * @generated from protobuf message user.GetUserAvatarResponse
 */
export interface GetUserAvatarResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional user.UserAvatar avatar = 2;
	 */
	avatar?: UserAvatar
	/**
	 * @generated from protobuf field: optional string message = 3;
	 */
	message?: string
}
/**
 * @generated from protobuf message user.DeleteUserAvatarRequest
 */
export interface DeleteUserAvatarRequest {
	/**
	 * @generated from protobuf field: int64 telegram_id = 1;
	 */
	telegramId: bigint
}
/**
 * @generated from protobuf message user.DeleteUserAvatarResponse
 */
export interface DeleteUserAvatarResponse {
	/**
	 * @generated from protobuf field: bool success = 1;
	 */
	success: boolean
	/**
	 * @generated from protobuf field: optional string message = 2;
	 */
	message?: string
}
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
	constructor() {
		super('user.User', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'created_at',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{ no: 3, name: 'nickname', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 4,
				name: 'points',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<User>): User {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = BigInt(0)
		message.createdAt = BigInt(0)
		message.nickname = ''
		message.points = BigInt(0)
		if (value !== undefined) reflectionMergePartial<User>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: User
	): User {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				case /* int64 created_at */ 2:
					message.createdAt = reader.int64().toBigInt()
					break
				case /* string nickname */ 3:
					message.nickname = reader.string()
					break
				case /* int64 points */ 4:
					message.points = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: User,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		/* int64 created_at = 2; */
		if (message.createdAt !== 0n)
			writer.tag(2, WireType.Varint).int64(message.createdAt)
		/* string nickname = 3; */
		if (message.nickname !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.nickname)
		/* int64 points = 4; */
		if (message.points !== 0n)
			writer.tag(4, WireType.Varint).int64(message.points)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.User
 */
export const User = new User$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserNicknameRequest$Type extends MessageType<UpdateUserNicknameRequest> {
	constructor() {
		super('user.UpdateUserNicknameRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'new_nickname',
				kind: 'scalar',
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(
		value?: PartialMessage<UpdateUserNicknameRequest>
	): UpdateUserNicknameRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		message.newNickname = ''
		if (value !== undefined)
			reflectionMergePartial<UpdateUserNicknameRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UpdateUserNicknameRequest
	): UpdateUserNicknameRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				case /* string new_nickname */ 2:
					message.newNickname = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UpdateUserNicknameRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		/* string new_nickname = 2; */
		if (message.newNickname !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.newNickname)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.UpdateUserNicknameRequest
 */
export const UpdateUserNicknameRequest = new UpdateUserNicknameRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
	constructor() {
		super('user.Task', [
			{
				no: 1,
				name: 'id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{ no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 3,
				name: 'description',
				kind: 'scalar',
				T: 9 /*ScalarType.STRING*/,
			},
			{ no: 4, name: 'is_automatic', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{
				no: 5,
				name: 'reward_points',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 6,
				name: 'progress',
				kind: 'scalar',
				opt: true,
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 7,
				name: 'goal',
				kind: 'scalar',
				opt: true,
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{ no: 8, name: 'completed', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
		])
	}
	create(value?: PartialMessage<Task>): Task {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.id = 0n
		message.name = ''
		message.description = ''
		message.isAutomatic = false
		message.rewardPoints = 0n
		message.completed = false
		if (value !== undefined) reflectionMergePartial<Task>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: Task
	): Task {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 id */ 1:
					message.id = reader.int64().toBigInt()
					break
				case /* string name */ 2:
					message.name = reader.string()
					break
				case /* string description */ 3:
					message.description = reader.string()
					break
				case /* bool is_automatic */ 4:
					message.isAutomatic = reader.bool()
					break
				case /* int64 reward_points */ 5:
					message.rewardPoints = reader.int64().toBigInt()
					break
				case /* optional int64 progress */ 6:
					message.progress = reader.int64().toBigInt()
					break
				case /* optional int64 goal */ 7:
					message.goal = reader.int64().toBigInt()
					break
				case /* bool completed */ 8:
					message.completed = reader.bool()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: Task,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 id = 1; */
		if (message.id !== 0n) writer.tag(1, WireType.Varint).int64(message.id)
		/* string name = 2; */
		if (message.name !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.name)
		/* string description = 3; */
		if (message.description !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.description)
		/* bool is_automatic = 4; */
		if (message.isAutomatic !== false)
			writer.tag(4, WireType.Varint).bool(message.isAutomatic)
		/* int64 reward_points = 5; */
		if (message.rewardPoints !== 0n)
			writer.tag(5, WireType.Varint).int64(message.rewardPoints)
		/* optional int64 progress = 6; */
		if (message.progress !== undefined)
			writer.tag(6, WireType.Varint).int64(message.progress)
		/* optional int64 goal = 7; */
		if (message.goal !== undefined)
			writer.tag(7, WireType.Varint).int64(message.goal)
		/* bool completed = 8; */
		if (message.completed !== false)
			writer.tag(8, WireType.Varint).bool(message.completed)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.Task
 */
export const Task = new Task$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetUserTasksRequest$Type extends MessageType<GetUserTasksRequest> {
	constructor() {
		super('user.GetUserTasksRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<GetUserTasksRequest>): GetUserTasksRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		if (value !== undefined)
			reflectionMergePartial<GetUserTasksRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetUserTasksRequest
	): GetUserTasksRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetUserTasksRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.GetUserTasksRequest
 */
export const GetUserTasksRequest = new GetUserTasksRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetUserTasksResponse$Type extends MessageType<GetUserTasksResponse> {
	constructor() {
		super('user.GetUserTasksResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{
				no: 2,
				name: 'tasks',
				kind: 'message',
				repeat: 1 /*RepeatType.PACKED*/,
				T: () => Task,
			},
			{
				no: 3,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(value?: PartialMessage<GetUserTasksResponse>): GetUserTasksResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		message.tasks = []
		if (value !== undefined)
			reflectionMergePartial<GetUserTasksResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetUserTasksResponse
	): GetUserTasksResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* repeated user.Task tasks */ 2:
					message.tasks.push(
						Task.internalBinaryRead(reader, reader.uint32(), options)
					)
					break
				case /* optional string message */ 3:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetUserTasksResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* repeated user.Task tasks = 2; */
		for (let i = 0; i < message.tasks.length; i++)
			Task.internalBinaryWrite(
				message.tasks[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options
			).join()
		/* optional string message = 3; */
		if (message.message !== undefined)
			writer.tag(3, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.GetUserTasksResponse
 */
export const GetUserTasksResponse = new GetUserTasksResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CompleteTaskRequest$Type extends MessageType<CompleteTaskRequest> {
	constructor() {
		super('user.CompleteTaskRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'task_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<CompleteTaskRequest>): CompleteTaskRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		message.taskId = 0n
		if (value !== undefined)
			reflectionMergePartial<CompleteTaskRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CompleteTaskRequest
	): CompleteTaskRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				case /* int64 task_id */ 2:
					message.taskId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: CompleteTaskRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		/* int64 task_id = 2; */
		if (message.taskId !== 0n)
			writer.tag(2, WireType.Varint).int64(message.taskId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.CompleteTaskRequest
 */
export const CompleteTaskRequest = new CompleteTaskRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CompleteTaskResponse$Type extends MessageType<CompleteTaskResponse> {
	constructor() {
		super('user.CompleteTaskResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{
				no: 2,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(value?: PartialMessage<CompleteTaskResponse>): CompleteTaskResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		if (value !== undefined)
			reflectionMergePartial<CompleteTaskResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CompleteTaskResponse
	): CompleteTaskResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional string message */ 2:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: CompleteTaskResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional string message = 2; */
		if (message.message !== undefined)
			writer.tag(2, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.CompleteTaskResponse
 */
export const CompleteTaskResponse = new CompleteTaskResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserRequest$Type extends MessageType<CreateUserRequest> {
	constructor() {
		super('user.CreateUserRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'referrer_id',
				kind: 'scalar',
				opt: true,
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{ no: 3, name: 'nickname', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(value?: PartialMessage<CreateUserRequest>): CreateUserRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		message.nickname = ''
		if (value !== undefined)
			reflectionMergePartial<CreateUserRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CreateUserRequest
	): CreateUserRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				case /* optional int64 referrer_id */ 2:
					message.referrerId = reader.int64().toBigInt()
					break
				case /* string nickname */ 3:
					message.nickname = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: CreateUserRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		/* optional int64 referrer_id = 2; */
		if (message.referrerId !== undefined)
			writer.tag(2, WireType.Varint).int64(message.referrerId)
		/* string nickname = 3; */
		if (message.nickname !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.nickname)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.CreateUserRequest
 */
export const CreateUserRequest = new CreateUserRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserResponse$Type extends MessageType<CreateUserResponse> {
	constructor() {
		super('user.CreateUserResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 2, name: 'user', kind: 'message', T: () => User },
			{
				no: 3,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
			{ no: 4, name: 'user_exists', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
		])
	}
	create(value?: PartialMessage<CreateUserResponse>): CreateUserResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		message.userExists = false
		if (value !== undefined)
			reflectionMergePartial<CreateUserResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CreateUserResponse
	): CreateUserResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional user.User user */ 2:
					message.user = User.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.user
					)
					break
				case /* optional string message */ 3:
					message.message = reader.string()
					break
				case /* bool user_exists */ 4:
					message.userExists = reader.bool()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: CreateUserResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional user.User user = 2; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options
			).join()
		/* optional string message = 3; */
		if (message.message !== undefined)
			writer.tag(3, WireType.LengthDelimited).string(message.message)
		/* bool user_exists = 4; */
		if (message.userExists !== false)
			writer.tag(4, WireType.Varint).bool(message.userExists)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.CreateUserResponse
 */
export const CreateUserResponse = new CreateUserResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UserResponse$Type extends MessageType<UserResponse> {
	constructor() {
		super('user.UserResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 2, name: 'user', kind: 'message', T: () => User },
			{
				no: 3,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(value?: PartialMessage<UserResponse>): UserResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		if (value !== undefined)
			reflectionMergePartial<UserResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UserResponse
	): UserResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional user.User user */ 2:
					message.user = User.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.user
					)
					break
				case /* optional string message */ 3:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UserResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional user.User user = 2; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options
			).join()
		/* optional string message = 3; */
		if (message.message !== undefined)
			writer.tag(3, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.UserResponse
 */
export const UserResponse = new UserResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UserRequest$Type extends MessageType<UserRequest> {
	constructor() {
		super('user.UserRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<UserRequest>): UserRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		if (value !== undefined)
			reflectionMergePartial<UserRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UserRequest
	): UserRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UserRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.UserRequest
 */
export const UserRequest = new UserRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetUserReferralsRequest$Type extends MessageType<GetUserReferralsRequest> {
	constructor() {
		super('user.GetUserReferralsRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(
		value?: PartialMessage<GetUserReferralsRequest>
	): GetUserReferralsRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		if (value !== undefined)
			reflectionMergePartial<GetUserReferralsRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetUserReferralsRequest
	): GetUserReferralsRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetUserReferralsRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.GetUserReferralsRequest
 */
export const GetUserReferralsRequest = new GetUserReferralsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UserReferralsResponse$Type extends MessageType<UserReferralsResponse> {
	constructor() {
		super('user.UserReferralsResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 2, name: 'data', kind: 'message', T: () => UserReferrals },
			{
				no: 3,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(value?: PartialMessage<UserReferralsResponse>): UserReferralsResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		if (value !== undefined)
			reflectionMergePartial<UserReferralsResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UserReferralsResponse
	): UserReferralsResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional user.UserReferrals data */ 2:
					message.data = UserReferrals.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.data
					)
					break
				case /* optional string message */ 3:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UserReferralsResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional user.UserReferrals data = 2; */
		if (message.data)
			UserReferrals.internalBinaryWrite(
				message.data,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options
			).join()
		/* optional string message = 3; */
		if (message.message !== undefined)
			writer.tag(3, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.UserReferralsResponse
 */
export const UserReferralsResponse = new UserReferralsResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UserReferrals$Type extends MessageType<UserReferrals> {
	constructor() {
		super('user.UserReferrals', [
			{
				no: 1,
				name: 'referrals',
				kind: 'scalar',
				repeat: 1 /*RepeatType.PACKED*/,
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'total_count',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<UserReferrals>): UserReferrals {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.referrals = []
		message.totalCount = 0n
		if (value !== undefined)
			reflectionMergePartial<UserReferrals>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UserReferrals
	): UserReferrals {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* repeated int64 referrals */ 1:
					if (wireType === WireType.LengthDelimited)
						for (let e = reader.int32() + reader.pos; reader.pos < e; )
							message.referrals.push(reader.int64().toBigInt())
					else message.referrals.push(reader.int64().toBigInt())
					break
				case /* int64 total_count */ 2:
					message.totalCount = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UserReferrals,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* repeated int64 referrals = 1; */
		if (message.referrals.length) {
			writer.tag(1, WireType.LengthDelimited).fork()
			for (let i = 0; i < message.referrals.length; i++)
				writer.int64(message.referrals[i])
			writer.join()
		}
		/* int64 total_count = 2; */
		if (message.totalCount !== 0n)
			writer.tag(2, WireType.Varint).int64(message.totalCount)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.UserReferrals
 */
export const UserReferrals = new UserReferrals$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserPointsRequest$Type extends MessageType<UpdateUserPointsRequest> {
	constructor() {
		super('user.UpdateUserPointsRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{
				no: 2,
				name: 'points',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(
		value?: PartialMessage<UpdateUserPointsRequest>
	): UpdateUserPointsRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		message.points = 0n
		if (value !== undefined)
			reflectionMergePartial<UpdateUserPointsRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UpdateUserPointsRequest
	): UpdateUserPointsRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				case /* int64 points */ 2:
					message.points = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UpdateUserPointsRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		/* int64 points = 2; */
		if (message.points !== 0n)
			writer.tag(2, WireType.Varint).int64(message.points)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.UpdateUserPointsRequest
 */
export const UpdateUserPointsRequest = new UpdateUserPointsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CheckAndUpdateTasksRequest$Type extends MessageType<CheckAndUpdateTasksRequest> {
	constructor() {
		super('user.CheckAndUpdateTasksRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(
		value?: PartialMessage<CheckAndUpdateTasksRequest>
	): CheckAndUpdateTasksRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		if (value !== undefined)
			reflectionMergePartial<CheckAndUpdateTasksRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CheckAndUpdateTasksRequest
	): CheckAndUpdateTasksRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: CheckAndUpdateTasksRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.CheckAndUpdateTasksRequest
 */
export const CheckAndUpdateTasksRequest = new CheckAndUpdateTasksRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CheckAndUpdateTasksResponse$Type extends MessageType<CheckAndUpdateTasksResponse> {
	constructor() {
		super('user.CheckAndUpdateTasksResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{
				no: 2,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(
		value?: PartialMessage<CheckAndUpdateTasksResponse>
	): CheckAndUpdateTasksResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		if (value !== undefined)
			reflectionMergePartial<CheckAndUpdateTasksResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CheckAndUpdateTasksResponse
	): CheckAndUpdateTasksResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional string message */ 2:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: CheckAndUpdateTasksResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional string message = 2; */
		if (message.message !== undefined)
			writer.tag(2, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.CheckAndUpdateTasksResponse
 */
export const CheckAndUpdateTasksResponse =
	new CheckAndUpdateTasksResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UserAvatar$Type extends MessageType<UserAvatar> {
	constructor() {
		super('user.UserAvatar', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{ no: 2, name: 'avatar_url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 3,
				name: 'updated_at',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<UserAvatar>): UserAvatar {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		message.avatarUrl = ''
		message.updatedAt = 0n
		if (value !== undefined)
			reflectionMergePartial<UserAvatar>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UserAvatar
	): UserAvatar {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				case /* string avatar_url */ 2:
					message.avatarUrl = reader.string()
					break
				case /* int64 updated_at */ 3:
					message.updatedAt = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: UserAvatar,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		/* string avatar_url = 2; */
		if (message.avatarUrl !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.avatarUrl)
		/* int64 updated_at = 3; */
		if (message.updatedAt !== 0n)
			writer.tag(3, WireType.Varint).int64(message.updatedAt)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.UserAvatar
 */
export const UserAvatar = new UserAvatar$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SetUserAvatarRequest$Type extends MessageType<SetUserAvatarRequest> {
	constructor() {
		super('user.SetUserAvatarRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
			{ no: 2, name: 'avatar_url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
		])
	}
	create(value?: PartialMessage<SetUserAvatarRequest>): SetUserAvatarRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		message.avatarUrl = ''
		if (value !== undefined)
			reflectionMergePartial<SetUserAvatarRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: SetUserAvatarRequest
	): SetUserAvatarRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				case /* string avatar_url */ 2:
					message.avatarUrl = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: SetUserAvatarRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		/* string avatar_url = 2; */
		if (message.avatarUrl !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.avatarUrl)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.SetUserAvatarRequest
 */
export const SetUserAvatarRequest = new SetUserAvatarRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SetUserAvatarResponse$Type extends MessageType<SetUserAvatarResponse> {
	constructor() {
		super('user.SetUserAvatarResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{
				no: 2,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(value?: PartialMessage<SetUserAvatarResponse>): SetUserAvatarResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		if (value !== undefined)
			reflectionMergePartial<SetUserAvatarResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: SetUserAvatarResponse
	): SetUserAvatarResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional string message */ 2:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: SetUserAvatarResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional string message = 2; */
		if (message.message !== undefined)
			writer.tag(2, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.SetUserAvatarResponse
 */
export const SetUserAvatarResponse = new SetUserAvatarResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetUserAvatarRequest$Type extends MessageType<GetUserAvatarRequest> {
	constructor() {
		super('user.GetUserAvatarRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(value?: PartialMessage<GetUserAvatarRequest>): GetUserAvatarRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		if (value !== undefined)
			reflectionMergePartial<GetUserAvatarRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetUserAvatarRequest
	): GetUserAvatarRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetUserAvatarRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.GetUserAvatarRequest
 */
export const GetUserAvatarRequest = new GetUserAvatarRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetUserAvatarResponse$Type extends MessageType<GetUserAvatarResponse> {
	constructor() {
		super('user.GetUserAvatarResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 2, name: 'avatar', kind: 'message', T: () => UserAvatar },
			{
				no: 3,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(value?: PartialMessage<GetUserAvatarResponse>): GetUserAvatarResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		if (value !== undefined)
			reflectionMergePartial<GetUserAvatarResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetUserAvatarResponse
	): GetUserAvatarResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional user.UserAvatar avatar */ 2:
					message.avatar = UserAvatar.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.avatar
					)
					break
				case /* optional string message */ 3:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: GetUserAvatarResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional user.UserAvatar avatar = 2; */
		if (message.avatar)
			UserAvatar.internalBinaryWrite(
				message.avatar,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options
			).join()
		/* optional string message = 3; */
		if (message.message !== undefined)
			writer.tag(3, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.GetUserAvatarResponse
 */
export const GetUserAvatarResponse = new GetUserAvatarResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DeleteUserAvatarRequest$Type extends MessageType<DeleteUserAvatarRequest> {
	constructor() {
		super('user.DeleteUserAvatarRequest', [
			{
				no: 1,
				name: 'telegram_id',
				kind: 'scalar',
				T: 3 /*ScalarType.INT64*/,
				L: 0 /*LongType.BIGINT*/,
			},
		])
	}
	create(
		value?: PartialMessage<DeleteUserAvatarRequest>
	): DeleteUserAvatarRequest {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.telegramId = 0n
		if (value !== undefined)
			reflectionMergePartial<DeleteUserAvatarRequest>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: DeleteUserAvatarRequest
	): DeleteUserAvatarRequest {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* int64 telegram_id */ 1:
					message.telegramId = reader.int64().toBigInt()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: DeleteUserAvatarRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* int64 telegram_id = 1; */
		if (message.telegramId !== 0n)
			writer.tag(1, WireType.Varint).int64(message.telegramId)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.DeleteUserAvatarRequest
 */
export const DeleteUserAvatarRequest = new DeleteUserAvatarRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DeleteUserAvatarResponse$Type extends MessageType<DeleteUserAvatarResponse> {
	constructor() {
		super('user.DeleteUserAvatarResponse', [
			{ no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{
				no: 2,
				name: 'message',
				kind: 'scalar',
				opt: true,
				T: 9 /*ScalarType.STRING*/,
			},
		])
	}
	create(
		value?: PartialMessage<DeleteUserAvatarResponse>
	): DeleteUserAvatarResponse {
		const message = globalThis.Object.create(this.messagePrototype!)
		message.success = false
		if (value !== undefined)
			reflectionMergePartial<DeleteUserAvatarResponse>(this, message, value)
		return message
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: DeleteUserAvatarResponse
	): DeleteUserAvatarResponse {
		let message = target ?? this.create(),
			end = reader.pos + length
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag()
			switch (fieldNo) {
				case /* bool success */ 1:
					message.success = reader.bool()
					break
				case /* optional string message */ 2:
					message.message = reader.string()
					break
				default:
					let u = options.readUnknownField
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						)
					let d = reader.skip(wireType)
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						)
			}
		}
		return message
	}
	internalBinaryWrite(
		message: DeleteUserAvatarResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool success = 1; */
		if (message.success !== false)
			writer.tag(1, WireType.Varint).bool(message.success)
		/* optional string message = 2; */
		if (message.message !== undefined)
			writer.tag(2, WireType.LengthDelimited).string(message.message)
		let u = options.writeUnknownFields
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(
				this.typeName,
				message,
				writer
			)
		return writer
	}
}
/**
 * @generated MessageType for protobuf message user.DeleteUserAvatarResponse
 */
export const DeleteUserAvatarResponse = new DeleteUserAvatarResponse$Type()
/**
 * @generated ServiceType for protobuf service user.UserService
 */
export const UserService = new ServiceType('user.UserService', [
	{
		name: 'CreateUser',
		options: {},
		I: CreateUserRequest,
		O: CreateUserResponse,
	},
	{ name: 'GetUser', options: {}, I: UserRequest, O: UserResponse },
	{
		name: 'GetUserReferrals',
		options: {},
		I: GetUserReferralsRequest,
		O: UserReferralsResponse,
	},
	{
		name: 'UpdateUserPoints',
		options: {},
		I: UpdateUserPointsRequest,
		O: UserResponse,
	},
	{
		name: 'GetUserTasks',
		options: {},
		I: GetUserTasksRequest,
		O: GetUserTasksResponse,
	},
	{
		name: 'CompleteTask',
		options: {},
		I: CompleteTaskRequest,
		O: CompleteTaskResponse,
	},
	{
		name: 'CheckAndUpdateTasks',
		options: {},
		I: CheckAndUpdateTasksRequest,
		O: CheckAndUpdateTasksResponse,
	},
	{
		name: 'SetUserAvatar',
		options: {},
		I: SetUserAvatarRequest,
		O: SetUserAvatarResponse,
	},
	{
		name: 'GetUserAvatar',
		options: {},
		I: GetUserAvatarRequest,
		O: GetUserAvatarResponse,
	},
	{
		name: 'DeleteUserAvatar',
		options: {},
		I: DeleteUserAvatarRequest,
		O: DeleteUserAvatarResponse,
	},
	{
		name: 'UpdateUserNickname',
		options: {},
		I: UpdateUserNicknameRequest,
		O: UserResponse,
	},
])
